# Безопасный доступ к регистрам на с++17 без оверхеда
 С++ благодаря своей строгой типизации может помочь программисту на этапе компиляции. Используя ООП подход можно добиться более приятной взгляду инициализации. Пример инициализации dma потока для микроконтроллера stm32:
 
```cpp
some_stream.set (Direction::to_periph)
   .inc_memory()
   .size_memory (DataSize::word16)
   .size_periph (DataSize::word16)
   .enable_transfer_complete_interrupt();
```
Работа с регистрами спрятана за читаемыми методами, а передаваемые аргументы являются отдельными типами с хорошо читаемыми названиями, что позволяет избежать ошибок при передаче неправильного аргумента.
 
Этот же код на CMSIS можно написать так:
```c
SOME_STREAM.CR |= DMA_SxCR_DIR_0
               |  DMA_SxCR_MINC_Msk
               |  DMA_SxCR_MSIZE_0
               |  DMA_SxCR_PSIZE_0
               |  DMA_SxCR_TCIE_Msk;
```
И вот тут, пишущие на си и считающие с++ излишним, могут возразить. В угоду читаемости в коде на с++ появляется оверхед, так как каждая функция на плюсах это отдельное обращение к регистру, которое нельзя оптимизировать при таком подходе. А на си без проблем записать сразу несколько параметров за одно обращение к регистру, собрав их в маску. Хотелось бы, чтобы и код был читаем и без ошибок и чтобы лишних обращений к регистру не было. И это возможно, но до 17 стандарта было довольно сложно. Сейчас же при появлении constexpr lambda и fold expression писать стало сильно проще. Плюс я как раз наткнулся на доклад про [value-based метапрограммирование](https://www.youtube.com/watch?v=ZUmc45Njs9U&list=PLZN9ZGiWZoZo3hYXXOn6NZAi3YzUETzy2&index=3), в сторону которого смотрит сейчас стандарт, и решил попробовать решить эту задачку, используя этот подход. Тут я и расскажу как у меня получилось.
<cut/>

Сначала опишем, что хотим.
```cpp
some_stream.set(
     dma_stream::direction::to_periph
   , dma_stream::inc_memory
   , dma_stream::memory_size::byte16
   , dma_stream::periph_size::byte16
   , dma_stream::transfer_complete_interrupt::enable
);
```
Каждый параметр в методе set - отдельный тип, по которому можно понять, в какой регистр надо записать значение, а значит во время компиляции можно оптимизировать обращение к регистрам. Метод вариодический, поэтому аргументов может быть любое количество, но при этом должна присутствовать проверка, что все аргументы относятся к данной периферии.
 
Писать буду абстрактно, не для конкретной периферии. Итак, у нас есть несколько полей регистров, условно запишем их в качестве перечислений.
```cpp
enum struct Enum1 { _0, _1, _2, _3 };
enum struct Enum2 { _0, _1, _2, _3 };
enum struct Enum3 { _0, _1, _2, _3, _4 };
enum struct Enum4 { _0, _1, _2, _3 };
```
Первые три будут относиться к одной периферии, четвертое к другой. Таким образом, если мы передадим значение четвёртого перечисления в метод первой периферии, должна быть ошибка компиляции, желательно понятная. Так же первые 2 перечисления будут относится к одному регистру, третье к другому.
 
Поскольку значения перечислений не хранят в себе ничего, кроме собственно значений, нам нужен дополнительный тип, который будет хранить, к примеру, маску, чтобы определять в какую часть регистра это перечисление будет записываться.
```cpp
struct Enum1_traits { static constexpr std::size_t mask = 0b00111; };
struct Enum2_traits { static constexpr std::size_t mask = 0b11000; };
struct Enum3_traits { static constexpr std::size_t mask = 0b00111; };
struct Enum4_traits { static constexpr std::size_t mask = 0b00111; };
```
Осталось связать эти 2 типа. Тут нам пригодится [фишка уже 20 стандарта](https://en.cppreference.com/w/cpp/types/type_identity), но она довольно тривиальна и можно реализовать её самому.
```cpp
template <class T> struct type_identity { using type = T; };
 
// получить значение типа
constexpr auto some_type = type_identity<Some_type>{};
 
// достать тип из значения типа
using some_type_t = typename decltype(some_type)::type;
```
Суть в том, что мы можем из типа сделать значение и передать её в функцию в качестве аргумента. Это главный кирпичик value-based подхода в метапрограммировании. Мы будем стараться передавать информацию о типе через значения, а не в качестве параметра шаблона. Связывающая перечисление и его свойства функция выглядит следующим образом:
```cpp
constexpr auto traits(type_identity<Enum1>) {
    return type_identity<Enum1_traits>{};
}
```
Необходимо наши поля связать с соответствующими регистрами. Я выбрал связь через наследование, поскольку в стандарте уже есть метафункция `std::is_base_of`, которая позволит определять связи между полями и регистрами уже в обобщенном виде. Наследоваться от перечислений нельзя, поэтому наследуемся от их свойств.
```cpp
struct Register1 : Enum1_traits, Enum2_traits {
   static constexpr std::size_t offset = 0x0;
};
```
Адрес, где находится регистр, сохраняем в виде смещения относительно начала периферии.
 
Перед тем, как описывать периферию, необходимо рассказать о списке типов в value-based метапрораммировании. Это довольно простая структура, которая позволяет сохранить несколько типов и передать их по значению. Немного напоминает `type_identity`, но для нескольких типов.
```cpp
template <class...Ts> struct type_pack{};
 
using empty_pack = type_pack<>;
```
Для этого списка можно реализовать множество constexpr функций. Часть из них будет описана здесь далее. Их реализация значительно проще в понимании, чем знаменитые списки типов Александреску (библиотека Loki).
 
Вторым важным свойством периферии должна быть возможность расположить ее как по конкретному адресу (в микроконтроллере), так и передать адрес динамически для тестов. Поэтому структура периферии будет шаблонной, и в качестве параметра принимать тип, который в поле value будет хранить конкретный адрес периферии. Параметр шаблона будем определять из конструктора. Ну и метод set, о котором говорилось ранее.
```cpp
template<class Address>
struct Periph1 {
   Periph1(Address) {}
 
   static constexpr auto registers = type_pack<Register1, Register2>{};
 
   template<class...Ts>
   static constexpr void set(Ts...args) {
       ::set(registers, Address::value, args...);
   }
};
```
Всё, что делает метод set - вызывает свободную функцию, передавая в неё всю необходимую для обобщенного алгоритма информацию.
 
Приведу примеры типов, предоставляющих адрес на периферию.
```cpp
// статический адрес микроконтроллера
struct Address { static constexpr std::size_t value = SOME_PERIPH_BASE; };
 
// динамический адрес для тестов, передается через конструктор
struct Address {
   static inline std::size_t value;
   template<class Pointer>
   Address(Pointer address) { value = reinterpret_cast<std::size_t>(address); }
};
```
 
Всю информацию для обобщенного алгоритма подготовили, осталось его реализовать. Приведу текст этой функции.
```cpp
template<class...Registers, class...Args>
constexpr void set(type_pack<Registers...> registers, std::size_t address, Args...args) {
   // из аргументов достаем их свойства и упаковываем, используя value based подход
   constexpr auto args_traits = make_type_pack(traits(type_identity<Args>{})...);
 
   // и теперь можно проверить все ли свойства аргументов являются базовыми для данной периферии
   static_assert(all_of(args_traits, [](auto arg){
       using arg_type = typename decltype(arg)::type;
       return (std::is_base_of<arg_type, Registers>::value || ...);
   }), "one of arguments in set method don`t belong to periph type");
 
   // определяем список регистров, в которые надо записывать данные
   constexpr auto registers_for_write = filter(registers, [=](auto reg){
       using reg_type = typename decltype(reg)::type;
       return any_of(args_traits, [](auto arg){
           using arg_type = typename decltype(arg)::type;
           return std::is_base_of_v<arg_type, reg_type>;
       });
   });
 
   // определяем значения в каждом регистре и пишем в его
   foreach(registers_for_write, [&](auto reg){
       auto value = register_value(reg, args...);
       auto offset = decltype(reg)::type::offset;
       write(address + offset, value);
   });
};
```
Реализация функции, которая преобразует аргументы (конкретные поля регистров) в `type_pack` довольно тривиальна. Напомню, что многоточие у шаблонного списка типов раскрывает список типов через запятую.
```cpp
template <class...Ts>
constexpr auto make_type_pack(type_identity<Ts>...) {
   return type_pack<Ts...>{};
}
```
Для проверки, что все аргументы относятся к переданным регистрам, а значит конкретной периферии, необходимо реализовать алгоритм all_of. По аналогии со стандартной библиотекой алгоритм принимает на вход список типов и функцию - предикат. В качестве функции используем лямбду.
```cpp
template <class F, class...Ts>
constexpr auto all_of(type_pack<Ts...> pack, F f) {
   return (f(type_identity<Ts>{}) and ...);
}
```
Тут мы впервые применили [выражение развёртки 17 стандарта](https://ru.cppreference.com/w/cpp/language/fold). Именно это нововведение сильно упрастило жизнь тем, кто увлекается метапрограммированием. Для примера приведу, во что раскроется выражение в функции. Применяется функция f для каждого из типов в списке Ts, преобразуя его к `type_identity`, а результат каждого вызова соберается по И.
 
Внутри `static_assert` применён этот алгоритм. В лямбду по очереди передается `args_traits`, обернутый в `type_identity`. Внутри лямбды добираемся до типа свойств аргумента, и используем стандартную метафункцию std::is_base_of, но поскольку у нас регистров может быть не один, используем выражение развёртки, чтобы выполнить ее для каждого из регистров по логике ИЛИ. В результате, если найдётся хоть один аргумент, свойства которого не являются базовым хотя бы для одного регистра, сработает `static assert` и выведет понятное сообщение об ошибке. По нему легко понять в каком именно месте ошибка (передан не тот аргумент в метод `set`) и исправить её.
 
Очень похожа и реализация алгоритма `any_of`, которая понадобится далее:
```cpp
template <class F, class...Ts>
constexpr auto any_of(type_pack<Ts...> pack, F f) {
   return (f(type_identity<Ts>{}) or ...);
}
```
Следующая задача нашей обобщенной функции - определить в какие регистры надо будет произвести запись. Для этого надо исходный список регистров отфильтровать и оставить только те, к которым есть аргументы в нашей функции. Нужен алгоритм `filter`, который возьмёт исходный `type_pack`, применит функцию предикат для каждого типа из списка, и если предикат вернет true, добавит его в новый список.
```cpp
template <class F, class...Ts>
constexpr auto filter(type_pack<Ts...> pack, F f) {
   auto filter_one = [](auto v, auto f) {
       using T = typename decltype(v)::type;
       if constexpr (f(v))
           return type_pack<T>{};
       else
           return empty_pack{};
   };
   return (empty_pack{} + ... + filter_one(type_identity<Ts>{}, f));
}
```
Вначале описана лямбда, которая выполняет функцию предикат над одним типом и возвращает `type_pack` с ним, если предикат вернул true, или пустой `type_pack`, если предикат вернул `false`. Тут помогает еще одна новая фишка последних плюсов - constexpr if. Её суть в том, что в результирующем коде остается только одна ветка if, вторая выбрасывается. А поскольку у нас в разных ветках возвращаются разные типы, без constexpr была бы ошибка компиляции. Результат выполнения этой лямбды для каждого типа из списка конкатенируется в один результирующий `type_pack` опять благодаря выражению развертки. Нам не хватает перегрузки оператора сложения для `type_pack`. Его реализация так же довольно проста:
```cpp
template <class...Ts, class...Us>
constexpr auto operator+ (type_pack<Ts...>, type_pack<Us...>) {
   return type_pack<Ts..., Us...>{};
}
```
Применяя новый алгоритм над списком регистров, оставляем лишь те, в которые надо записать переданные аргументы.
 
Следующий алгоритм, который понадобится это `foreach`. Он просто применяет функцию к каждому типу из списка, оборачивая его в `type_identity`. Тут в выражении развертки применяется оператор запятая, которая выполняет все действия, описанные через запятую и возвращает результат последнего действия.
```cpp
template <class F, class...Ts>
constexpr void foreach(type_pack<Ts...> pack, F f) {
   (f(type_identity<Ts>{}), ...);
}
```
Используем этот алгоритм, чтобы добраться до каждого из регистров, куда надо писать. Вычислим выражение для записи и запишем его по нужному адресу.
 
Для того, чтобы вычислить значение конкретного регистра, вычислим его для каждого аргумента, к которому относится этот регистр и объединим результат по ИЛИ.
```cpp
template<class Register, class...Args>
constexpr std::size_t register_value(type_identity<Register> reg, Args...args) {
   std::size_t value {0};
   // бинарные операторы недопустимы в выражениях развертки, поэтому делаем лямбду-обертку
   auto change = [](auto& value, auto arg_value) {
       value |= arg_value;
   };
   (change(value, arg_value(reg, args)), ...);
   return value;
}
```
Вычисление значения для конкретного поля должно выполняться только для аргументов, от которых этот регистр наследуется. Для аргумента достаем из его свойства маску, по маске определяем смещение значения внутри регистра.
```cpp
template<class Register, class Arg>
constexpr std::size_t arg_value(type_identity<Register>, Arg arg) {
   constexpr auto arg_traits = traits(type_identity<Arg>{});
   using Arg_traits = typename decltype(arg_traits)::type;
   constexpr auto arg_shift = shift(Arg_traits::mask);
   return std::is_base_of_v<Arg_traits, Register> ? (static_cast<std::size_t>(arg) << arg_shift) : 0;
}
```
Алгоритм, определяющий смещение по маске, можно написать самому, но я воспользовался уже существующей builtin функцией.
```cpp
constexpr auto shift(std::size_t mask) {
   return __builtin_ffs(mask) - 1;
}
```
Осталась последняя функция, которая пишет значение по конкретному адресу.
```cpp
inline void write(std::size_t address, std::size_t v) {
   *reinterpret_cast<std::size_t*>(address) |= v;
}
```
Всё тут написанное объединил вместе, добавил комментарии и скомпилировал в [godbolt](https://godbolt.org/z/pFv4yF), где видно, что поставленная цель выполнена: нет лишних обращений к памяти. Значение, которое необходимо записать в регистры вычисляется на этапе компиляции.